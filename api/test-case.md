# API — POST /api/v1/users

Эндпоинт: `POST /api/v1/users`  
Пример валидного тела запроса:
```json
{
  "name": "Анна",
  "email": "anna@example.com",
  "age": 27
}
```
Ожидаемый успешный ответ:
```json
{
  "id": 123,
  "name": "Анна",
  "email": "anna@example.com",
  "age": 27,
  "status": "active"
}
```

---

## 1) Что валидировать + 3 некорректных запроса

**Поля (валидируем на бэкенде):**
- **name** — обязательное, строка 2–50, буквы/пробел/дефис, не только пробелы
- **email** — обязательное, формат, уникальность (case-insensitive), длина ≤255
- **age** — обязательное целое число `0..120` 

**Не корректные запросы:**

**Bad #1 (пустое имя):**
~~~json
{"name": "", "email": "anna@example.com", "age": 27}
~~~

**Bad #2 (невалидный email):**
~~~json
{"name": "Анна", "email": "anna_at_example.com", "age": 27}
~~~

**Bad #3 (дубликат email, отличается только регистром):**
~~~json
{"name": "Анна", "email": "anna@example.com", "age": 27}
~~~
~~~json
{"name": "Анна", "email": "ANNA@example.com", "age": 27}
~~~
> Примечание: этот кейс валиден, если бекенд проверяет уникальность e-mail **без учёта регистра**. 
> Если оба запроса вернут 201 — это дефект валидации.

---

## 2) Что проверить в headers

**Request:**  
`Content-Type: application/json`, `Accept: application/json` *(при необходимости)* `Authorization: Bearer …`

**Response:**  
`Content-Type: application/json; charset=utf-8`; при **201** — `Location: /api/v1/users/{id}`; *(опц.)* `X-Request-Id`, 
`Cache-Control: no-store`.

---

## 3) Какие типы тестирования через Postman

## 3) Какие типы тестирования через Postman
- Функциональное (POS/NEG): проверяю, что эндпоинт делает то, что должен; 
валидные запросы → успех, невалидные → корректные ошибки (400/422/409 и т. п.).
- Контракт/схема: через JSON Schema в тестах Postman — типы полей, обязательные поля, формат email и т. д.
- Авторизация (базово): с токеном пускает, без/с плохим токеном даёт 401/403; проверяю нужные заголовки.
- Smoke/регресс: небольшой стабильный набор автотестов в коллекции, запускаю в Runner/Newman.
- Лёгкая производительность: контролирую время ответа (pm.response.responseTime) и простые повторы; для реальной 
нагрузки — уже не Postman.
- Пагинация/фильтры: проверяю page/limit, next/prev, что фильтры и сортировки работают и счётчики совпадают.

---

## 4) Ожидаемые коды ответа

- **201 Created** — успешное создание  
- **400 Bad Request** или **422 Unprocessable Entity** — ошибка валидации  
- **409 Conflict** — e-mail уже существует (регистронезависимо)

---

## 5) Тест-кейс (формальный)

**ID:** API-POST-User-201  
**Предусловия:** сервис доступен; `anna.unique@example.com` не занят.

**Шаги:**
1) Отправить `POST /api/v1/users` с телом:
   ~~~json
   {"name": "Анна", "email": "anna.unique@example.com", "age": 27}
   ~~~
2) Проверить статус и заголовки ответа.  
3) Проверить тело ответа (типы и значения полей).

**Ожидаемый результат:**
- Статус: **201**  
- Заголовки: `Content-Type=application/json; charset=utf-8`, `Location=/api/v1/users/{id}`  
- Тело:
  ~~~json
  {
    "id": 123, 
    "name": "Анна",
    "email": "anna.unique@example.com",
    "age": 27,
    "status": "active"
  }
  ~~~
  Где:
  - `id` — целое число > 0  
  - `name/email/age` — совпадают с запросом  
  - `status` — `"active"`

**Негативные проверки (отдельными запросами):**
- Пустое имя / плохой email / `age<0` или `age>120` → **400/422**  
- Повторный POST с тем же email (в любом регистре) → **409**
